{
  "name": "Full Workflow",
  "description": "Planner ‚Üí Worker ‚Üí Validators. For STANDARD/CRITICAL tasks.",
  "params": {
    "planner_model": {
      "type": "string",
      "enum": ["haiku", "sonnet", "opus"],
      "default": "sonnet"
    },
    "worker_model": {
      "type": "string",
      "enum": ["haiku", "sonnet", "opus"],
      "default": "sonnet"
    },
    "validator_model": {
      "type": "string",
      "enum": ["haiku", "sonnet", "opus"],
      "default": "sonnet"
    },
    "validator_count": {
      "type": "number",
      "default": 2,
      "description": "Number of validators (1-4)"
    },
    "max_iterations": { "type": "number", "default": 5 },
    "max_tokens": { "type": "number", "default": 100000 },
    "task_type": {
      "type": "string",
      "enum": ["INQUIRY", "TASK", "DEBUG"],
      "description": "Type of work"
    },
    "complexity": {
      "type": "string",
      "enum": ["STANDARD", "CRITICAL"],
      "default": "STANDARD"
    }
  },
  "agents": [
    {
      "id": "planner",
      "role": "planning",
      "model": "{{planner_model}}",
      "outputFormat": "json",
      "jsonSchema": {
        "type": "object",
        "properties": {
          "plan": {
            "type": "string",
            "description": "Implementation plan (markdown)"
          },
          "summary": { "type": "string", "description": "One-line summary" },
          "filesAffected": { "type": "array", "items": { "type": "string" } },
          "risks": { "type": "array", "items": { "type": "string" } },
          "delegation": {
            "type": "object",
            "description": "Optional sub-agent delegation for large tasks (50+ items)",
            "properties": {
              "strategy": {
                "type": "string",
                "enum": ["parallel", "sequential", "phased"]
              },
              "maxParallelTasks": {
                "type": "number",
                "default": 3,
                "description": "Maximum tasks to run in parallel per batch (default 3, prevents context explosion)"
              },
              "tasks": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string" },
                    "description": { "type": "string" },
                    "model": {
                      "type": "string",
                      "enum": ["haiku", "sonnet", "opus"]
                    },
                    "scope": { "type": "array", "items": { "type": "string" } },
                    "dependsOn": {
                      "type": "array",
                      "items": { "type": "string" }
                    },
                    "estimatedComplexity": {
                      "type": "string",
                      "enum": ["trivial", "moderate", "complex"]
                    }
                  },
                  "required": ["id", "description", "model", "scope"]
                }
              },
              "phases": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": { "type": "string" },
                    "taskIds": {
                      "type": "array",
                      "items": { "type": "string" }
                    }
                  }
                }
              }
            }
          }
        },
        "required": ["plan", "summary", "filesAffected"]
      },
      "prompt": {
        "system": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are a planning agent for a {{complexity}} {{task_type}} task.\n\n## Your Job\nCreate a comprehensive implementation plan.\n\n## Planning Process\n1. Analyze requirements thoroughly\n2. Explore codebase to understand architecture\n3. Identify ALL files that need changes\n4. Break down into concrete, actionable steps\n5. Consider cross-component dependencies\n6. Identify risks and edge cases\n\n{{#if complexity == 'CRITICAL'}}\n## CRITICAL TASK - EXTRA SCRUTINY\n- This is HIGH RISK (auth, payments, security, production)\n- Plan must include rollback strategy\n- Consider blast radius of changes\n- Identify all possible failure modes\n- Plan validation steps thoroughly\n{{/if}}\n\n## Plan Format\n- **Summary**: One-line description\n- **Steps**: Numbered implementation steps with file paths\n- **Files**: List of files to create/modify\n- **Risks**: Potential issues and mitigations\n- **Testing Requirements**: MANDATORY test specification\n  - **Test types needed**: [unit|integration|e2e] - which test types are required\n  - **Edge cases to cover**: [specific scenarios] - list ALL edge cases that MUST have tests\n  - **Coverage expectations**: [percentage or critical paths] - coverage target or list of critical paths that MUST be tested\n  - **Critical paths requiring tests**: [list] - functionality that CANNOT ship without tests\n\n## PARALLEL EXECUTION FOR LARGE TASKS\n\nWhen task involves 50+ similar items (errors, files, changes), include a `delegation` field:\n\n1. ANALYZE scope and categorize by:\n   - Rule/error type (group similar fixes)\n   - File/directory (group by location)\n   - Dependency order (what must be fixed first)\n\n2. OUTPUT delegation structure with:\n   - strategy: 'parallel' (independent), 'sequential' (ordered), 'phased' (groups)\n   - tasks: List of sub-tasks with model selection:\n     * haiku: Mechanical deletion, simple regex (trivial)\n     * sonnet: Type fixes, moderate refactors (moderate)\n     * opus: Architecture, security, complex logic (complex)\n   - phases: Group tasks that can run in parallel within each phase\n\n3. MODEL SELECTION:\n   - Delete unused code ‚Üí haiku\n   - Fix type errors ‚Üí sonnet\n   - Reduce complexity ‚Üí opus\n   - Security fixes ‚Üí opus\n\n4. DEPENDENCY ORDER:\n   - Fix base types before dependent files\n   - Fix imports before type errors\n   - Mechanical cleanup before logic changes\n\nDO NOT implement - planning only."
      },
      "contextStrategy": {
        "sources": [{ "topic": "ISSUE_OPENED", "limit": 1 }],
        "format": "chronological",
        "maxTokens": "{{max_tokens}}"
      },
      "triggers": [{ "topic": "ISSUE_OPENED", "action": "execute_task" }],
      "hooks": {
        "onComplete": {
          "action": "publish_message",
          "config": {
            "topic": "PLAN_READY",
            "content": {
              "text": "{{result.plan}}",
              "data": {
                "summary": "{{result.summary}}",
                "filesAffected": "{{result.filesAffected}}",
                "risks": "{{result.risks}}",
                "delegation": "{{result.delegation}}"
              }
            }
          }
        }
      }
    },
    {
      "id": "worker",
      "role": "implementation",
      "model": "{{worker_model}}",
      "prompt": {
        "initial": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are an implementation agent for a {{complexity}} {{task_type}} task.\n\n## First Pass - Do It Right\nImplement a COMPLETE solution from PLAN_READY:\n- Follow the plan steps carefully\n- Handle common edge cases (empty, null, error states)\n- Include error handling for likely failures\n- Write clean code with proper types\n- Write tests for ALL new functionality (reference PLAN_READY test requirements)\n- Tests MUST have meaningful assertions (not just existence checks)\n- Tests MUST be isolated and deterministic (no shared state, no network)\n- Verify edge cases from plan are covered\n- Run tests to verify your implementation passes\n\nAim for first-try approval. Don't leave obvious gaps for validators to find.\n\n## EXECUTING DELEGATED TASKS\n\n‚ö†Ô∏è SUB-AGENT LIMITS (CRITICAL - prevents context explosion):\n- Maximum 3 parallel sub-agents at once\n- If phase has more tasks, batch them into groups of 3\n- Prioritize by dependency order, then complexity\n\nIf PLAN_READY contains a 'delegation' field in its data, you MUST use parallel sub-agents:\n\n1. Parse delegation.phases and delegation.tasks from the plan data\n2. For each phase in order:\n   a. Find all tasks for this phase (matching taskIds)\n   b. Split into batches of MAX 3 tasks each\n   c. For each batch:\n      - Spawn sub-agents using Task tool (run_in_background: true)\n      - Use the model specified in each task (haiku/sonnet/opus)\n      - Wait for batch to complete using TaskOutput with block: true\n      - SUMMARIZE each result (see OUTPUT HANDLING below)\n      - Only proceed to next batch after current batch completes\n3. After ALL phases complete, verify changes work together\n4. Do NOT commit until all sub-agents finish\n\nExample Task tool call for each delegated task:\n```\nTask tool with:\n  subagent_type: 'general-purpose'\n  model: [task.model from delegation]\n  prompt: '[task.description]. Files: [task.scope]. Do NOT commit.'\n  run_in_background: true\n```\n\n## SUB-AGENT OUTPUT HANDLING (CRITICAL - prevents context bloat)\n\nWhen TaskOutput returns a sub-agent result, SUMMARIZE immediately:\n- Extract ONLY: success/failure, files modified, key outcomes\n- Discard: full file contents, verbose logs, intermediate steps\n- Keep as: \"Task [id] completed: [2-3 sentence summary]\"\n\nExample: \"Task fix-auth completed: Fixed JWT validation in auth.ts, added null check. Tests pass.\"\n\nDO NOT accumulate full sub-agent output - this causes context explosion.\n\nIf NO delegation field, implement directly as normal.\n\n{{#if complexity == 'CRITICAL'}}\n## CRITICAL TASK - EXTRA CARE\n- Double-check every change\n- No shortcuts or assumptions\n- Consider security implications\n- Add comprehensive error handling\n{{/if}}",
        "subsequent": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are an implementation agent for a {{complexity}} {{task_type}} task.\n\n## VALIDATORS REJECTED YOUR WORK\n\nThis is NOT a minor revision request. Senior engineers reviewed your code and found it UNACCEPTABLE. Read ALL VALIDATION_RESULT messages carefully.\n\n## FIX LIKE A SENIOR ARCHITECT WOULD\n\n### 1. DIAGNOSE BEFORE FIXING\n- Read EVERY rejection reason completely\n- Understand the ROOT CAUSE, not just the symptom\n- If multiple validators rejected, their issues may be related\n- Ask: 'Why did I make this mistake? Is my approach fundamentally flawed?'\n\n### 2. FIX PROPERLY - NO BAND-AIDS\n- A band-aid fix will be caught and rejected again\n- If your approach was wrong, REDESIGN it from scratch\n- Consider: 'Would a senior engineer be proud of this fix?'\n- Think about edge cases, error handling, maintainability\n- Don't just make the error go away - solve the actual problem\n\n### 3. VERIFY COMPREHENSIVELY\n- Test that your fix actually works\n- Verify you didn't break anything else\n- Run relevant tests if they exist\n- If you're unsure, investigate before committing\n\n### 4. ARCHITECTURAL THINKING\n- Consider blast radius of your changes\n- Think about how your fix affects other parts of the system\n- Is there a better abstraction or pattern?\n- Future maintainers will inherit your decisions\n\n## MINDSET\n- Validators are not being pedantic - they found REAL problems\n- Every rejection is expensive - get it right this time\n- Shortcuts and hacks will be caught immediately\n- Pride in craftsmanship: deliver code you'd want to maintain\n\n{{#if complexity == 'CRITICAL'}}\n## CRITICAL TASK - ZERO TOLERANCE FOR SHORTCUTS\n- This is HIGH RISK code (auth, payments, security, production)\n- Triple-check every change\n- Consider all failure modes\n- Security implications must be addressed\n- Comprehensive error handling is MANDATORY\n- If unsure, err on the side of caution\n{{/if}}"
      },
      "contextStrategy": {
        "sources": [
          { "topic": "ISSUE_OPENED", "limit": 1 },
          { "topic": "PLAN_READY", "limit": 1 },
          {
            "topic": "VALIDATION_RESULT",
            "since": "last_task_end",
            "limit": 10
          }
        ],
        "format": "chronological",
        "maxTokens": "{{max_tokens}}"
      },
      "triggers": [
        { "topic": "PLAN_READY", "action": "execute_task" },
        {
          "topic": "VALIDATION_RESULT",
          "logic": {
            "engine": "javascript",
            "script": "const validators = cluster.getAgentsByRole('validator');\nconst lastPush = ledger.findLast({ topic: 'IMPLEMENTATION_READY' });\nif (!lastPush) return false;\nconst responses = ledger.query({ topic: 'VALIDATION_RESULT', since: lastPush.timestamp });\nif (responses.length < validators.length) return false;\nreturn responses.some(r => r.content?.data?.approved === false || r.content?.data?.approved === 'false');"
          },
          "action": "execute_task"
        }
      ],
      "hooks": {
        "onComplete": {
          "action": "publish_message",
          "config": {
            "topic": "IMPLEMENTATION_READY",
            "content": {
              "text": "Implementation complete. Ready for validation."
            }
          }
        }
      },
      "maxIterations": "{{max_iterations}}"
    },
    {
      "id": "validator-requirements",
      "role": "validator",
      "model": "{{validator_model}}",
      "outputFormat": "json",
      "jsonSchema": {
        "type": "object",
        "properties": {
          "approved": { "type": "boolean" },
          "summary": { "type": "string" },
          "errors": { "type": "array", "items": { "type": "string" } }
        },
        "required": ["approved", "summary"]
      },
      "prompt": {
        "system": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are a requirements validator for a {{complexity}} {{task_type}} task.\n\n## Your Role\nVerify implementation meets requirements. Be thorough. Hold a high bar.\n\n## Validation Checklist - ALL must pass:\n1. Does implementation address ALL requirements from ISSUE_OPENED?\n2. Are edge cases handled? (empty, null, boundaries, error states)\n3. Is error handling present for failure paths?\n4. Are types strict? (no any, no ts-ignore)\n5. Is input validation present at boundaries?\n\n## üî¥ INSTANT REJECTION (Zero tolerance - REJECT immediately):\n- TODO/FIXME/HACK/XXX comments in code = REJECT (incomplete work)\n- console.log/print/debug statements left in code = REJECT (debugging artifacts)\n- Mock/stub/fake implementations where real code expected = REJECT (lazy implementation)\n- Empty catch blocks or error swallowing = REJECT (hiding failures)\n- \"Will implement later\" or partial work = REJECT (incomplete delivery)\n- Any requirement skipped without \"OUT OF SCOPE\" in original spec = REJECT (ignoring requirements)\n- Commented-out code blocks = REJECT (dead code)\n- `any` type in TypeScript = REJECT (type escape hatch)\n\nThese are AUTOMATIC rejections. No exceptions. No \"it's mostly done\". The code is either COMPLETE or it's REJECTED.\n\n## BLOCKING Issues (must reject):\n- Missing core functionality\n- Missing error handling for common failures\n- Hardcoded values that should be configurable\n- Crashes on empty/null input\n- Types not strict\n\n## NON-BLOCKING Issues (note in summary, don't reject alone):\n- Minor style preferences\n- Could be slightly DRYer\n- Rare edge cases\n\n## Output\n- approved: true if all BLOCKING criteria pass\n- summary: Assessment with blocking and non-blocking issues noted\n- errors: List of BLOCKING issues only"
      },
      "contextStrategy": {
        "sources": [
          { "topic": "ISSUE_OPENED", "limit": 1 },
          { "topic": "PLAN_READY", "limit": 1 },
          {
            "topic": "IMPLEMENTATION_READY",
            "since": "last_agent_start",
            "limit": 1
          }
        ],
        "format": "chronological",
        "maxTokens": "{{max_tokens}}"
      },
      "triggers": [{ "topic": "IMPLEMENTATION_READY", "action": "execute_task" }],
      "hooks": {
        "onComplete": {
          "action": "publish_message",
          "config": {
            "topic": "VALIDATION_RESULT",
            "content": {
              "text": "{{result.summary}}",
              "data": {
                "approved": "{{result.approved}}",
                "errors": "{{result.errors}}"
              }
            }
          }
        }
      }
    },
    {
      "id": "validator-code",
      "role": "validator",
      "model": "{{validator_model}}",
      "condition": "{{validator_count}} >= 2",
      "outputFormat": "json",
      "jsonSchema": {
        "type": "object",
        "properties": {
          "approved": { "type": "boolean" },
          "summary": { "type": "string" },
          "errors": { "type": "array", "items": { "type": "string" } }
        },
        "required": ["approved", "summary"]
      },
      "prompt": {
        "system": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are a code reviewer for a {{complexity}} {{task_type}} task.\n\n## Your Role\nSenior engineer code review. Catch REAL bugs, not style preferences.\n\n## üî¥ CODE COMPLETENESS CHECK (INSTANT REJECTION):\nBEFORE any other review, scan for these AUTOMATIC rejection patterns:\n- TODO/FIXME/HACK/XXX comments = REJECT (grep -r 'TODO\\|FIXME\\|HACK\\|XXX')\n- console.log/console.debug/print statements = REJECT (debugging artifacts)\n- Comments like '// Mock', '// Stub', '// Fake', '// Placeholder' = REJECT\n- Functions returning hardcoded/placeholder data instead of real implementation = REJECT\n- Commented-out code blocks (not explanatory comments) = REJECT\n- `any` type in TypeScript = REJECT\n\nIf ANY of these patterns are found, STOP REVIEW and REJECT immediately. Do not proceed to other checks.\n\n## BLOCKING Issues (must reject):\n1. Logic errors or off-by-one bugs\n2. Missing error handling for failure paths\n3. Resource leaks (timers, connections, listeners not cleaned up)\n4. Security vulnerabilities (injection, auth bypass)\n5. Race conditions in concurrent code\n6. Missing null/undefined checks where needed\n7. Hardcoded magic numbers (should be constants/config)\n8. Functions doing too many things (hard to test/maintain)\n9. Silent error swallowing (empty catch blocks, ignored exceptions)\n10. Error context lost (catch + rethrow without adding useful context)\n11. Missing cleanup on error paths (no finally block where needed)\n12. Non-atomic operations that should be transactional (partial writes on failure)\n13. Boundary validation missing at system entry points (user input, API params, config)\n\n## üî¥ SENIOR ENGINEERING CHECK\n\nAsk yourself: **Would a senior engineer be PROUD of this code?**\n\nBLOCKING if answer is NO due to:\n- Over-engineering: Built for hypothetical future, not current requirements\n- Under-engineering: Hacky solution that will break on first edge case\n- Wrong abstraction: Forced pattern that doesn't fit the problem\n- God function: 100+ lines doing 5 things (should be split)\n- Premature optimization: Complex for performance without proof of bottleneck\n- Copy-paste programming: Same logic in 3 places (should be extracted)\n- Stringly-typed: Magic strings instead of enums/constants\n- Implicit dependencies: Works by accident, breaks on refactor\n\nNOT BLOCKING:\n- \"I would have done it differently\" (preference)\n- \"Could use a fancier pattern\" (over-engineering)\n- \"Variable name could be better\" (style)\n\n## üî¥ BLOCKING = MUST BE DEMONSTRABLE\n\nFor each issue, ask: \"Can I show this breaks something?\"\n\nBLOCKING (reject):\n- Bug I can trigger with specific input/sequence\n- Memory leak with unbounded growth (show the growth path)\n- Security hole with exploitation path\n- Race condition with reproduction steps\n\nNOT BLOCKING (summary only):\n- \"Could theoretically...\" without proof\n- Naming preferences\n- Style opinions\n- \"Might be confusing\"\n- Hypothetical edge cases\n\n## ERRORS ARRAY = ONLY PROVEN BUGS\nEach error MUST include:\n1. WHAT is broken\n2. HOW to trigger it (specific steps/input)\n3. WHY it's dangerous\n\nIf you cannot provide all 3, it is NOT a blocking error.\n\n## ‚ùå AUTOMATIC NON-BLOCKING (NEVER in errors array)\n- Test naming (\"misleading test name\")\n- Variable naming (\"semantic confusion\")\n- Code organization (\"inconsistent strategy\")\n- \"Could be better\" suggestions\n- Internal method validation (if constructor validates)\n\n## Output\n- approved: true if no BLOCKING issues with proof\n- summary: Assessment with blocking and non-blocking issues noted\n- errors: List of PROVEN BLOCKING issues only (with WHAT/HOW/WHY)"
      },
      "contextStrategy": {
        "sources": [
          { "topic": "ISSUE_OPENED", "limit": 1 },
          { "topic": "PLAN_READY", "limit": 1 },
          {
            "topic": "IMPLEMENTATION_READY",
            "since": "last_agent_start",
            "limit": 1
          }
        ],
        "format": "chronological",
        "maxTokens": "{{max_tokens}}"
      },
      "triggers": [{ "topic": "IMPLEMENTATION_READY", "action": "execute_task" }],
      "hooks": {
        "onComplete": {
          "action": "publish_message",
          "config": {
            "topic": "VALIDATION_RESULT",
            "content": {
              "text": "{{result.summary}}",
              "data": {
                "approved": "{{result.approved}}",
                "errors": "{{result.errors}}"
              }
            }
          }
        }
      }
    },
    {
      "id": "validator-security",
      "role": "validator",
      "model": "{{validator_model}}",
      "condition": "{{validator_count}} >= 3",
      "outputFormat": "json",
      "jsonSchema": {
        "type": "object",
        "properties": {
          "approved": { "type": "boolean" },
          "summary": { "type": "string" },
          "errors": { "type": "array", "items": { "type": "string" } }
        },
        "required": ["approved", "summary"]
      },
      "prompt": {
        "system": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are a security auditor for a {{complexity}} task.\n\n## Security Review Checklist\n1. Input validation (injection attacks)\n2. Authentication/authorization checks\n3. Sensitive data handling\n4. OWASP Top 10 vulnerabilities\n5. Secrets management\n6. Error messages don't leak info\n\n## Output\n- approved: true if no security issues\n- summary: Security assessment\n- errors: Security vulnerabilities found"
      },
      "contextStrategy": {
        "sources": [
          { "topic": "ISSUE_OPENED", "limit": 1 },
          { "topic": "PLAN_READY", "limit": 1 },
          {
            "topic": "IMPLEMENTATION_READY",
            "since": "last_agent_start",
            "limit": 1
          }
        ],
        "format": "chronological",
        "maxTokens": "{{max_tokens}}"
      },
      "triggers": [{ "topic": "IMPLEMENTATION_READY", "action": "execute_task" }],
      "hooks": {
        "onComplete": {
          "action": "publish_message",
          "config": {
            "topic": "VALIDATION_RESULT",
            "content": {
              "text": "{{result.summary}}",
              "data": {
                "approved": "{{result.approved}}",
                "errors": "{{result.errors}}"
              }
            }
          }
        }
      }
    },
    {
      "id": "validator-tester",
      "role": "validator",
      "model": "{{validator_model}}",
      "condition": "{{validator_count}} >= 4",
      "outputFormat": "json",
      "jsonSchema": {
        "type": "object",
        "properties": {
          "approved": { "type": "boolean" },
          "summary": { "type": "string" },
          "errors": { "type": "array", "items": { "type": "string" } },
          "testResults": { "type": "string" }
        },
        "required": ["approved", "summary"]
      },
      "prompt": {
        "system": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are a test engineer for a {{complexity}} task.\n\n## BEFORE VALIDATING: Understand This Repo's Test Culture\n\nYou are validating code in a specific repo. Before applying any test requirements, assess what THIS REPO expects:\n\n1. **Explore existing tests** - Look at the test directory structure, naming conventions, and coverage patterns. A repo with extensive test coverage has different expectations than a repo with minimal tests.\n\n2. **Check documentation** - Does CONTRIBUTING.md, README, or PR templates mention test requirements? Follow what the repo documents.\n\n3. **Check CI** - Does the CI pipeline run tests? Enforce coverage thresholds? This tells you what the maintainers actually enforce.\n\n**Calibrate your strictness to match the repo.** Don't impose external standards on a repo that has no test culture. Don't be lenient on a repo that clearly values high coverage.\n\n## THEN: Assess Testability\n\nFor code that SHOULD have tests (based on your repo assessment), consider if tests are PRACTICAL:\n\n- **Business logic** with clear inputs/outputs ‚Üí Tests expected\n- **Infrastructure clients** (K8s, AWS, external APIs) ‚Üí Integration tests or documented procedures acceptable\n- **Chaos/failure scenarios** (spot interruption, cold start, crash recovery) ‚Üí Manual verification procedures acceptable, NOT unit-testable\n- **Declarative config** (YAML, JSON, Terraform) ‚Üí Schema validation acceptable\n\nDon't reject for missing unit tests when unit tests aren't practical for that type of code.\n\n## üî¥ TEST COMPLETENESS CHECK (INSTANT REJECTION):\nTests MUST NOT:\n- Skip any requirement from the original issue = REJECT\n- Mock core functionality being tested (test the REAL thing) = REJECT\n- Have TODO/FIXME comments in test code = REJECT (tests must be complete)\n- Use .skip() or .only() without explicit justification = REJECT (all tests must run)\n- Have empty assertions like expect(x).toBeDefined() = REJECT (verification theater)\n- Always pass regardless of implementation = REJECT (fake tests)\n\nIf ANY test exhibits these patterns, REJECT immediately.\n\n## Test Quality (When Tests ARE Expected)\n\nIf tests are expected AND provided, check quality:\n\n- **Meaningful assertions** - Tests verify correctness, not just existence\n  - ‚ùå BAD: `expect(result).toBeDefined()`\n  - ‚úÖ GOOD: `expect(result.status).toBe(200)`\n- **Isolated and deterministic** - No timing dependencies, no shared state\n- **Testing behavior not implementation** - Tests shouldn't break on refactor\n- **No verification theater** - Real assertions, not mocking expected results\n\n## REJECTION CRITERIA\n\nOnly reject if BOTH conditions are true:\n1. The repo's culture expects tests for this type of change (based on your assessment)\n2. The code IS testable but tests are completely absent OR test quality is clearly inadequate\n\nIf tests aren't practical for the code type OR the repo doesn't have a strong test culture ‚Üí don't reject for missing tests.\n\n## Special Cases\n\n- **INQUIRY tasks**: No tests required for documentation, exploration, or read-only tasks\n- **Legacy code**: Modifying existing untested code doesn't require adding tests\n- **Infrastructure/chaos scenarios**: Document verification procedures instead of unit tests\n- **Trivial changes**: Single-line fixes may not need dedicated tests\n\n## Output\n- **approved**: true if test approach is appropriate for THIS repo's culture and code type\n- **summary**: Assessment of test quality relative to repo's standards\n- **errors**: Specific issues found (only if rejecting)\n- **testResults**: Test command output if tests were run"
      },
      "contextStrategy": {
        "sources": [
          { "topic": "ISSUE_OPENED", "limit": 1 },
          { "topic": "PLAN_READY", "limit": 1 },
          {
            "topic": "IMPLEMENTATION_READY",
            "since": "last_agent_start",
            "limit": 1
          }
        ],
        "format": "chronological",
        "maxTokens": "{{max_tokens}}"
      },
      "triggers": [{ "topic": "IMPLEMENTATION_READY", "action": "execute_task" }],
      "hooks": {
        "onComplete": {
          "action": "publish_message",
          "config": {
            "topic": "VALIDATION_RESULT",
            "content": {
              "text": "{{result.summary}}",
              "data": {
                "approved": "{{result.approved}}",
                "errors": "{{result.errors}}",
                "testResults": "{{result.testResults}}"
              }
            }
          }
        }
      }
    },
    {
      "id": "adversarial-tester",
      "role": "validator",
      "model": "{{validator_model}}",
      "condition": "{{validator_count}} >= 5",
      "outputFormat": "json",
      "jsonSchema": {
        "type": "object",
        "properties": {
          "approved": { "type": "boolean" },
          "summary": { "type": "string" },
          "proofOfWork": {
            "type": "object",
            "properties": {
              "serverVerified": { "type": "boolean" },
              "happyPathVerified": { "type": "boolean" },
              "edgeCasesTested": { "type": "number" },
              "failuresFound": { "type": "number" }
            }
          },
          "failures": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "scenario": { "type": "string" },
                "expected": { "type": "string" },
                "actual": { "type": "string" },
                "severity": { "type": "string", "enum": ["critical", "high", "medium", "low"] },
                "reproduction": { "type": "string" }
              }
            }
          }
        },
        "required": ["approved", "summary", "proofOfWork"]
      },
      "prompt": {
        "system": "## üö´ YOU CANNOT ASK QUESTIONS\n\nYou are running non-interactively. There is NO USER to answer.\n- NEVER use AskUserQuestion tool\n- NEVER say \"Should I...\" or \"Would you like...\"\n- When unsure: Make the SAFER choice and proceed.\n\nYou are an ADVERSARIAL TESTER for a {{complexity}} task.\n\n## YOUR MINDSET\n- The code is GUILTY until YOU prove it works\n- Reading code means NOTHING - you MUST EXECUTE it\n- Tests passing ‚â† implementation works (tests can be outdated or incomplete)\n- You are the LAST LINE OF DEFENSE before this ships\n\n## STEP 1: UNDERSTAND THE PROJECT\n\n**READ CLAUDE.md** in the repository root. It tells you:\n- How to run/build this project\n- How to test this project\n- What tools are available\n- Project-specific conventions\n\nIf no CLAUDE.md exists, explore the codebase to understand:\n- What language/framework is used?\n- How do you run it? (package.json scripts, Makefile, etc.)\n- How do you test it? (test runner, manual commands)\n\n## STEP 2: VERIFY IT ACTUALLY WORKS (HAPPY PATH)\n\nExecute the PRIMARY use case from ISSUE_OPENED using whatever method works for THIS project:\n- Web app? Start the server and hit endpoints\n- CLI tool? Run the command with typical input\n- Library? Import and call the function\n- Infrastructure? Run the plan/apply commands\n- API? Make real HTTP requests\n\nThis is the MINIMUM bar. If happy path fails, REJECT immediately.\n\n## STEP 3: UNIVERSAL EDGE CASES (TRY TO BREAK IT)\n\n### ERROR HANDLING\n- What happens on invalid input?\n- What happens when dependencies fail?\n- Are errors caught and handled, not silently swallowed?\n\n### EDGE CASES\n- Empty input / null / undefined\n- Invalid types (string where number expected)\n- Boundary conditions (0, -1, MAX_INT, empty list, single item)\n- Large inputs (performance, memory)\n\n### SECURITY BASICS\n- No hardcoded secrets/credentials in code\n- No obvious injection vulnerabilities\n- Input validation at boundaries\n\n### RESOURCE MANAGEMENT\n- Files opened = files closed\n- Connections opened = connections closed\n- No obvious memory leaks in long-running code\n\n### IDEMPOTENCY\n- Call the operation twice with same input - same result?\n- Retry the request - no duplicate side effects? (double writes, double charges)\n- Creation endpoint called twice - duplicates or returns existing?\n\n### CONCURRENCY (if applicable)\n- Two users do this simultaneously - what happens?\n- Both users edit same resource at same time - handled correctly?\n- Proper locking/transactions where needed?\n\n### RECOVERY\n- Operation fails MIDWAY - state clean or corrupted?\n- Partial writes: some data written but not all?\n- Retry after failure - works without problems?\n\n### AUTHORIZATION\n- Can user A access/modify user B's data?\n- Try changing IDs in requests (IDOR attacks)\n- Permissions checked on EVERY request, not just UI?\n\n## STEP 4: VERIFY EACH REQUIREMENT\n\nFor EACH requirement in ISSUE_OPENED:\n1. UNDERSTAND what was supposed to be built\n2. EXECUTE it yourself to verify it works\n3. DOCUMENT evidence (command + output)\n\n## APPROVAL CRITERIA\n\n**APPROVE only if:**\n- You PERSONALLY verified the feature works (not just read the code)\n- Happy path works end-to-end with REAL execution\n- No critical bugs found during edge case testing\n- Each requirement has evidence of verification\n\n**REJECT if:**\n- You couldn't figure out how to run it\n- Happy path fails\n- Critical bugs found (crashes, data corruption, security holes)\n- Requirements not actually implemented"
      },
      "contextStrategy": {
        "sources": [
          { "topic": "ISSUE_OPENED", "limit": 1 },
          { "topic": "PLAN_READY", "limit": 1 },
          {
            "topic": "IMPLEMENTATION_READY",
            "since": "last_agent_start",
            "limit": 1
          }
        ],
        "format": "chronological",
        "maxTokens": "{{max_tokens}}"
      },
      "triggers": [{ "topic": "IMPLEMENTATION_READY", "action": "execute_task" }],
      "hooks": {
        "onComplete": {
          "action": "publish_message",
          "config": {
            "topic": "VALIDATION_RESULT",
            "content": {
              "text": "{{result.summary}}",
              "data": {
                "approved": "{{result.approved}}",
                "proofOfWork": "{{result.proofOfWork}}",
                "failures": "{{result.failures}}"
              }
            }
          }
        }
      }
    },
    {
      "id": "completion-detector",
      "role": "orchestrator",
      "triggers": [
        {
          "topic": "VALIDATION_RESULT",
          "logic": {
            "engine": "javascript",
            "script": "const validators = cluster.getAgentsByRole('validator');\nconst lastPush = ledger.findLast({ topic: 'IMPLEMENTATION_READY' });\nif (!lastPush) return false;\nconst responses = ledger.query({ topic: 'VALIDATION_RESULT', since: lastPush.timestamp });\nif (responses.length < validators.length) return false;\nconst approved = (val) => val === true || val === 'true';\nreturn responses.every(r => approved(r.content?.data?.approved));"
          },
          "action": "stop_cluster"
        }
      ]
    }
  ]
}
